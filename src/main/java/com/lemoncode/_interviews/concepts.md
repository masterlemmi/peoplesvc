1. LOGARITHM
log complexity better than linear time
e.g. 
array of length 8 - > cut it in half everytime = log 8 = 3.. u cut it 3 times
binary tree -> every path u take, you element the other half at each level
binary search -> find a word in a dictionary
   
question: am i cutting/elemintatin my input in half? -- then we are doing logN time


2. GRAPH TRAVERSAL (dfs/bfs/dykstra)
DFS - recursive going to children
BFS - add results to queue.  (poll - take head, add (to end))

3. Binary Search Algorithm  ... find matched element of pivoted array

4. Sliding Window Technique/Manipulating Pointers (longest palindrome)

5. invert a binary tree

6. reverse linked list

7. Tries / Complex Trie/ Suffix Tree --- TODO
   Standard Trie - space O(length of text)
   Compress Trie - space O(count of words)
   

8. Heaps (min/max) --> represent into array

9. Dynamic Programming/Memoization (proactice)

10. Sorting (quicksort/mergesort)

11. Matching Parentheses (Using Stack)

12. garbage collection
    threadsafe collections
    java 11 features
    java 8 features
    time space complexity
    data structures
    2 phase commit
    transaction
    circuit breaker
    design patterns
    big O - (n) (n2) (a*b), factorial(0(n)), fib(2n),
    mention leadership principlesn
